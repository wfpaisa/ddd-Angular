# Rendimiento de Compilaci√≥n con Nx

Hasta ahora, hemos sentado las bases para una arquitectura Angular mantenible. Hemos estado pensando en la divisi√≥n de dominios (domain slicing), la categorizaci√≥n de m√≥dulos y la aplicaci√≥n de reglas basadas en ellos con Sheriff.

Este cap√≠tulo complementa nuestra soluci√≥n con medidas para mejorar el rendimiento de compilaci√≥n. Para ello, cambiaremos al conocido sistema de compilaci√≥n Nx.

üìÅ [C√≥digo Fuente](https://github.com/manfredsteyer/modern-arc.git) (ver diferentes ramas)

## Compilaciones Incrementales ‚Äì Primeros Pasos

Las compilaciones incrementales consisten en reconstruir solo las partes modificadas del repositorio y, por lo tanto, permiten acelerar enormemente el proceso de compilaci√≥n. Para este prop√≥sito, la soluci√≥n se divide en varias aplicaciones. Esto significa que solo la aplicaci√≥n que acaba de ser modificada debe ser reconstruida. Lo mismo se aplica a la ejecuci√≥n de pruebas.

La siguiente instrucci√≥n crea otra aplicaci√≥n en un espacio de trabajo:

```
ng g app miles
```

Las bibliotecas se pueden usar para compartir c√≥digo entre aplicaciones:

```
ng g lib auth
```

Todas las aplicaciones y bibliotecas configuradas de esta manera son parte del mismo espacio de trabajo y repositorio. Por lo tanto, no es necesario distribuir las bibliotecas a trav√©s de npm:

![Estructura de carpetas de una biblioteca](images/lib.png)

El archivo `public-api.ts`, a veces tambi√©n llamado `index.ts`, tiene una tarea especial. Define la API p√∫blica de la biblioteca:

```typescript
// public-api.ts

export * from "./lib/auth.service";
```

Todos los constructos publicados aqu√≠ son visibles para otras bibliotecas y aplicaciones. El resto se considera un detalle de implementaci√≥n privado. Para conceder acceso a una biblioteca a otras bibliotecas y aplicaciones en el mismo espacio de trabajo, se debe configurar un mapeo de rutas correspondiente en el archivo `tsconfig.json` central:

```json
[‚Ä¶]
"paths": {
  "@demo/auth": [
    "auth/src/public-api.ts"
  ],
  [‚Ä¶]
}
[‚Ä¶]
```

Llamar a `ng g lib` se encarga de este mapeo de rutas. Sin embargo, la implementaci√≥n de la CLI de Angular hace que apunte a la carpeta `dist` y, por lo tanto, a la versi√≥n compilada. Esto significa que el autor tendr√≠a que reconstruir la biblioteca despu√©s de cada cambio. Para evitar este molesto proceso, el listado anterior hace que el mapeo apunte a la versi√≥n del c√≥digo fuente de la biblioteca. A diferencia de la CLI, la herramienta Nx mencionada m√°s adelante se encarga de esto autom√°ticamente.

Una vez configurado el mapeo de rutas, las aplicaciones y bibliotecas individuales pueden importar las exportaciones de la API p√∫blica:

```typescript
import { AuthService } from "@demo/auth";
```

## M√°s c√≥modo y m√°s potente: Nx

La soluci√≥n de la secci√≥n anterior es simple, pero tiene una pega: los desarrolladores deben saber qu√© aplicaciones han cambiado y activar manualmente el comando de compilaci√≥n correspondiente. Y el servidor de compilaci√≥n probablemente todav√≠a tenga que reconstruir y probar todas las aplicaciones para mayor seguridad.

Ser√≠a mejor dejar que las herramientas averig√ºen qu√© aplicaciones han cambiado. Para hacer esto, podr√≠as calcular un valor hash para todos los archivos fuente que influyen en tus aplicaciones. Cada vez que un valor hash cambia, se puede asumir que la aplicaci√≥n correspondiente necesita ser reconstruida o probada.

Nx es una soluci√≥n popular que respalda esta idea y viene con muchas caracter√≠sticas adicionales. Adem√°s de Angular, tambi√©n admite otras tecnolog√≠as como React o backends basados en Node.js, e integra numerosas herramientas com√∫nmente utilizadas en el desarrollo de soluciones basadas en web. Ejemplos son las herramientas de prueba Jest, Cypress y Playwright, el servidor npm _verdaccio_ y Storybook utilizado para la documentaci√≥n interactiva de componentes. Los desarrolladores no tienen que invertir ning√∫n esfuerzo en configurar dichas herramientas, sino que pueden empezar directamente.

Para las compilaciones incrementales, Nx utiliza una cach√© de compilaci√≥n. Debido a que Nx analiza las dependencias entre las partes individuales del programa, estos mecanismos a menudo no requieren configuraci√≥n manual. Nx se siente muy natural, especialmente para los desarrolladores de Angular: La CLI de Nx se puede usar de manera similar a la CLI de Angular. Simplemente cambias la instrucci√≥n `ng` por `nx`; los argumentos habituales permanecen en gran medida iguales (`nx build`, `nx serve`, `nx g app`, `nx g lib`, etc.). La CLI de Nx se instala a trav√©s de npm:

```
npm i -g nx
```

Para crear un nuevo espacio de trabajo Nx, ejecuta el siguiente comando:

```
npx create-nx-workspace@latest my-project
```

Para tu primer proyecto, selecciona las siguientes opciones:

![Opciones para tu primer proyecto Nx](images/create-nx-workspace.png)

Este comando hace que npm cargue un script que configura un espacio de trabajo Nx con la versi√≥n actual de Nx. Tambi√©n hay scripts para migrar espacios de trabajo de la CLI a Nx, aunque no siempre activan la gama completa de caracter√≠sticas de Nx. Por esta raz√≥n, hemos tenido mejores experiencias creando un nuevo espacio de trabajo Nx y, si es necesario, copiando el c√≥digo fuente existente. Como es habitual con la CLI de Angular, el espacio de trabajo se puede dividir luego en varias aplicaciones y bibliotecas:

```
nx g app apps/appName

nx g lib libs/libName
```

Es una convenci√≥n habitual de Nx colocar las aplicaciones Angular en la carpeta `apps` y las bibliotecas Angular en la carpeta `libs`. Tambi√©n aqu√≠, usa la configuraci√≥n predeterminada para tus primeros proyectos Nx. Sin embargo, sugerir√≠a una excepci√≥n a esta regla: comienza con el nuevo constructor (builder) esbuild, ya que proporciona un mejor rendimiento de compilaci√≥n en comparaci√≥n con el tradicional basado en webpack.

Una llamada a

```
nx graph
```

ilustra las dependencias entre aplicaciones y bibliotecas:

![Un grafo de dependencias simple](images/graph-klein.png)

## Compilaciones Incrementales con Nx

Los datos utilizados para el grafo de dependencias tambi√©n son la base para las compilaciones incrementales que Nx ofrece de forma predeterminada. Para compilar un proyecto espec√≠fico, puedes usar `nx build`:

```
nx build miles
```

Si los archivos fuente que influyen en la aplicaci√≥n afectada no han cambiado, recibir√°s inmediatamente el resultado de la cach√© local. Por defecto, esta se encuentra en una carpeta `.nx` excluida en el archivo `.gitignore` de tu proyecto.

Tambi√©n se puede indicar a Nx que reconstruya ciertos proyectos o todos:

```
npx nx run-many --target=build --projects=flights,miles

npx nx run-many --target=build --all
```

En este caso, tambi√©n, Nx recurre a la cach√© si los archivos fuente no han cambiado:

![Nx permite compilaciones incrementales sin configuraci√≥n](images/nx-build.png)

Las pruebas unitarias, las pruebas E2E y el linting tambi√©n se pueden realizar incrementalmente de la misma manera. Nx incluso va un paso m√°s all√° y almacena en cach√© estas acciones a nivel de biblioteca. Esto mejora el rendimiento al dividir la aplicaci√≥n en varias bibliotecas.

En principio, esto tambi√©n ser√≠a posible para `nx build`, siempre que las bibliotecas individuales se creen como `buildable` (`nx g lib myLib --buildable`). Sin embargo, se ha demostrado que este enfoque rara vez conduce a ventajas de rendimiento y que las reconstrucciones incrementales de aplicaciones son preferibles.

## Nota al Margen: Micro Frontends

Las aplicaciones compiladas por separado se pueden integrar en tiempo de ejecuci√≥n, dando a los usuarios la sensaci√≥n de trabajar con una √∫nica aplicaci√≥n. Para este prop√≥sito, se utilizan t√©cnicas conocidas del mundo de los micro frontends. Este tema se discute en varios otros cap√≠tulos.

## Cach√© Distribuida con Nx Cloud

Por defecto, Nx configura una cach√© local. Si quieres ir un paso m√°s all√°, usa una cach√© distribuida a la que todo el equipo del proyecto y el servidor de compilaci√≥n puedan acceder. Esto significa que tambi√©n te beneficias de las compilaciones que otros ya han realizado. La [Nx Cloud](https://nx.app/) ‚Äì un complemento comercial para el Nx gratuito ‚Äì ofrece dicha cach√©. Si no quieres o no puedes usar proveedores de nube, tambi√©n puedes alojar Nx Cloud t√∫ mismo.

Para conectar un espacio de trabajo Nx a Nx Cloud, solo se necesita un comando:

```
npx nx connect-to-nx-cloud
```

T√©cnicamente, este comando activa el ejecutor de tareas (task runner) `nx-cloud` en el archivo `nx.json` ubicado en la ra√≠z del proyecto:

```json
"tasksRunnerOptions": {
  "default": {
    "runner": "nx-cloud",
    "options": {
      "cacheableOperations": [
        "build",
        "test",
        "lint"
      ],
      "accessToken": "[‚Ä¶]"
    }
  }
},
```

Un ejecutor de tareas se encarga de la ejecuci√≥n de tareas individuales, como las que est√°n detr√°s de `nx build`, `nx lint` o `nx test`. La implementaci√≥n predeterminada almacena en cach√© los resultados de estas tareas en el sistema de archivos, como se discuti√≥ anteriormente. El Ejecutor de Tareas `nx-cloud`, por otro lado, delega a una cuenta en Nx Cloud.

Esto tambi√©n muestra que el ejecutor de tareas y, por lo tanto, la estrategia de cach√© se pueden intercambiar con relativa facilidad. Algunos proyectos de c√≥digo abierto aprovechan esto y ofrecen ejecutores de tareas que utilizan sus propias fuentes de datos como AWS (ver [aqu√≠](https://www.npmjs.com/package/@magile/nx-distributed-cache) y [aqu√≠](https://github.com/bojanbass/nx-aws)), [GCP](https://github.com/MansaGroup/nx-gcs-remote-cache), [Azure](https://npmjs.com/package/nx-remotecache-azure), o [Minio](https://npmjs.com/package/nx-remotecache-minio). Gracias a [Lars Gyrup Brink Nielsen](https://twitter.com/LayZeeDK) por se√±alarme estas soluciones.

Sin embargo, debe tenerse en cuenta que la API del ejecutor de tareas no es p√∫blica y, por lo tanto, puede cambiar de una versi√≥n a otra.

El ejecutor de tareas para Nx Cloud tambi√©n necesita configurarse con un token de acceso (ver arriba). Comandos como _nx build_ generan un enlace a una cuenta en la nube creada din√°micamente. Al acceder por primera vez, es aconsejable crear usuarios para restringir el acceso a ellos. Tambi√©n puedes encontrar un panel (dashboard) bajo este enlace que proporciona informaci√≥n sobre las compilaciones realizadas:

![El panel de Nx proporciona informaci√≥n sobre las compilaciones completadas](images/dashboard.png)

## A√∫n M√°s R√°pido: Paralelizaci√≥n con Nx Cloud

Para acelerar a√∫n m√°s el proceso de compilaci√≥n, Nx Cloud ofrece la opci√≥n de paralelizar tareas de compilaci√≥n individuales. Aqu√≠, tambi√©n, el grafo de dependencias demuestra ser una ventaja: Nx puede usarlo para averiguar el orden en que deben realizarse las tareas individuales o qu√© tareas se pueden paralelizar.

Se utilizan diferentes nodos en la nube para la paralelizaci√≥n: un nodo principal se encarga de la coordinaci√≥n y varios nodos trabajadores (worker nodes) se ocupan de las tareas individuales en paralelo. Nx incluso puede generar scripts de compilaci√≥n que inician y proporcionan tareas a estos nodos. Por ejemplo, la siguiente instrucci√≥n genera un flujo de trabajo (workflow) para GitHub:

```
nx generate @nx/workspace:ci-workflow --ci=github
```

Este comando tambi√©n es compatible con CircleCI (`--ci=circleci`) y Azure (`--ci==azure`). Si optas por otro entorno, al menos puedes usar los flujos de trabajo generados como punto de partida. Esencialmente, estos scripts especifican el n√∫mero deseado de nodos trabajadores y el n√∫mero de procesos paralelos por nodo trabajador. Los comandos activados se dividen en tres grupos: comandos que se ejecutan secuencialmente para la inicializaci√≥n (`init-commands`), comandos que se ejecutan en paralelo en el nodo principal (`parallel-commands`) y comandos que los trabajadores ejecutan en paralelo (`parallel-commands`) en los agentes.

Los scripts se activan cada vez que la rama principal del repositorio cambia, ya sea por un `push` directo o al fusionar una pull request:

![Paralelizaci√≥n con Nx Cloud y GitHub Actions](images/dte.png)

## Conclusi√≥n

Nx permite acelerar dr√°sticamente las tareas de compilaci√≥n. Esto es posible, entre otras cosas, gracias a las compilaciones incrementales, en las que solo se reconstruyen o prueban las partes de la aplicaci√≥n que realmente han cambiado. Nx Cloud ofrece opciones de aceleraci√≥n adicionales con su cach√© distribuida. Tambi√©n permite paralelizar las compilaciones individuales. Debido a que Nx analiza el c√≥digo del programa y reconoce las dependencias entre aplicaciones y bibliotecas individuales, estas opciones a menudo no requieren configuraci√≥n manual.
